* Application unlock
  struct flock lck: verrou à poser (de type F_UNLCK)
  rl_lock cur: verrou courant lors du parcours de la table de locks

  on suppose les verrous de longueur finie
  pour lck.l_start, utiliser `get_starting_offset`

  apply_unlock(flock ul, rl_descriptor lfd):
  begin
      nb_new_locks := 0
      new_locks := new rl_lock[2 * lfd.file->nb_locks]
      nb_locks_to_remove := 0
      locks_to_remove := new int[lfd.file->nb_locks]
      lfd_owner = {.pid = pid, .fd = lfd.fd}
      Pour cur dans lfd.file->lock_table:
          Si lfd_owner est proprio de cur & seg_overlap(cur, ul):
              Traiter les cas ci-dessous
          Si nb_new_locks + lfd.file->nb_locks > RL_MAX_LOCKS:
              Retourner -1
      Pour i de 0 à nb_locks_to_remove:
          ind = locks_to_remove[i]
          Si lfd_owner est le dernier owner de lfd.file->lock_table[ind]:
              supprimer lfd.file->lock_table[i]
          Sinon
              retirer lfd_owner de lfd.file->lock_table[ind].lock_owners
      Pour i de 0 à nb_new_locks:
          Si lfd.file->lock_table contient new_locks[i]:
              Ajouter lfd_owner aux owners
          Sinon
              lfd.file->lock_table[lfd.file->nb_locks] = new_locks[i]
              lfd.file->nb_locks += 1
  end

** C1: unlock au milieu de  cur
   <=> cur.start < lck.l_start & cur.len > lck.l_len
*** Conséquences
    Ajouter l'indice de cur à locks_to_remove
    Incrémenter nb_locks_to_remove

    Ajout de 2 nouveaux verrous: 
    nb_new_locks += 2;
    v1.type = cur.type;
    v1.start = cur.start;
    v1.len = lck.l_start - cur.start

    v2.type = cur.type;
    v2.start = lck.l_start + lck.l_len
    v2.len = (cur.start + cur.len) - (lck.l_start + lck.l_len)
** C2: unlock tout cur
   <=> cur.start >= lck.l_start & cur.len <= lck.l_len
*** Conséquences
    Ajouter l'indice de cur à locks_to_remove
    Incrémenter nb_locks_to_remove
** C3: unlock la fin de la zone de cur
   <=> cur.start < lck.l_start 
   & (cur.start + cur.len <= lck.l_start + lck.l_len)
*** Conséquences
    Ajouter l'indice de cur à locks_to_remove
    Incrémenter nb_locks_to_remove
    
    Ajout de 1 nouveau verrou:
    nb_new_locks++;
    v1.type = cur.type;
    v1.start = cur.start;
    v1.len = lck.start - cur.start;
** C4: unlock le début de la zone de cur
   <=> lck.l_start < cur.start & (cur.start + cur.len >= lck.l_start)
*** Conséquences
    Ajouter l'indice de cur à locks_to_remove
    Incrémenter nb_locks_to_remove

    Ajout de 1 nouveau verrou:
    nb_new_locks++;
    v1.type = cur.type;
    v1.start = lck.l_start + lck.l_len
    v1.len = (cur.start + cur.len) - (lck.l_start + lck.l_len)
* Application read/write lock
